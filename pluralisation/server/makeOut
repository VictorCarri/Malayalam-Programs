g++-9 -o obj/debug/dynamic/Connection.o -c cpp/Connection.cpp -fPIC -I./hpp -I/home/victor/include -I/usr/include/mysql -Wall -Werror -std=gnu++17 -DDEBUG -ggdb3 -ggnu-pubnames -gvariable-location-views -ginline-points -Og -fvar-tracking-assignments -save-temps -DUSE_STD_BIND -DUSE_STD_ENABLE_SHARED_FROM_THIS -DUSE_STD_SHARED_PTR -DUSE_STD_THREAD 2>&1
cpp/Connection.cpp: In member function ‘void Connection::handleRead(const boost::system::error_code&, std::size_t)’:
cpp/Connection.cpp:84:54: error: use of deleted function ‘mpp::Reply& mpp::Reply::operator=(const mpp::Reply&)’
   84 |    rep = mpp::Reply::stockReply(reqParser.getStatus()); // Generate a stock reply using the error code which the parser identified
      |                                                      ^
In file included from /home/victor/include/mpp/ReqHandler.hpp:22,
                 from cpp/Connection.cpp:10:
/home/victor/include/mpp/Reply.hpp:22:8: note: ‘mpp::Reply& mpp::Reply::operator=(const mpp::Reply&)’ is implicitly deleted because the default definition would be ill-formed:
   22 |  class Reply
      |        ^~~~~
/home/victor/include/mpp/Reply.hpp:22:8: error: passing ‘const std::array<char, 2>’ as ‘this’ argument discards qualifiers [-fpermissive]
In file included from /usr/include/c++/9/tuple:39,
                 from /usr/include/c++/9/bits/unique_ptr.h:37,
                 from /usr/include/c++/9/memory:80,
                 from /usr/local/include/boost/asio/associated_allocator.hpp:19,
                 from /usr/local/include/boost/asio.hpp:20,
                 from cpp/Connection.cpp:2:
/usr/include/c++/9/array:94:12: note:   in call to ‘constexpr std::array<char, 2>& std::array<char, 2>::operator=(const std::array<char, 2>&)’
   94 |     struct array
      |            ^~~~~
In file included from /home/victor/include/mpp/ReqHandler.hpp:22,
                 from cpp/Connection.cpp:10:
/home/victor/include/mpp/Reply.hpp:22:8: error: passing ‘const std::array<char, 2>’ as ‘this’ argument discards qualifiers [-fpermissive]
   22 |  class Reply
      |        ^~~~~
In file included from /usr/include/c++/9/tuple:39,
                 from /usr/include/c++/9/bits/unique_ptr.h:37,
                 from /usr/include/c++/9/memory:80,
                 from /usr/local/include/boost/asio/associated_allocator.hpp:19,
                 from /usr/local/include/boost/asio.hpp:20,
                 from cpp/Connection.cpp:2:
/usr/include/c++/9/array:94:12: note:   in call to ‘constexpr std::array<char, 2>& std::array<char, 2>::operator=(const std::array<char, 2>&)’
   94 |     struct array
      |            ^~~~~
cpp/Connection.cpp: In member function ‘void Connection::handleWrite(const boost::system::error_code&)’:
cpp/Connection.cpp:128:74: error: no matching function for call to ‘boost::asio::basic_stream_socket<boost::asio::ip::tcp>::shutdown(boost::asio::socket_base::shutdown_type, boost::system::error_code*)’
  128 |   socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, &ignoredEc);
      |                                                                          ^
In file included from /usr/local/include/boost/asio/basic_datagram_socket.hpp:20,
                 from /usr/local/include/boost/asio.hpp:24,
                 from cpp/Connection.cpp:2:
/usr/local/include/boost/asio/basic_socket.hpp:1656:8: note: candidate: ‘void boost::asio::basic_socket<Protocol, Executor>::shutdown(boost::asio::socket_base::shutdown_type) [with Protocol = boost::asio::ip::tcp; Executor = boost::asio::executor]’
 1656 |   void shutdown(shutdown_type what)
      |        ^~~~~~~~
/usr/local/include/boost/asio/basic_socket.hpp:1656:8: note:   candidate expects 1 argument, 2 provided
In file included from /usr/local/include/boost/asio/basic_datagram_socket.hpp:20,
                 from /usr/local/include/boost/asio.hpp:24,
                 from cpp/Connection.cpp:2:
/usr/local/include/boost/asio/basic_socket.hpp:1685:29: note: candidate: ‘boost::system::error_code boost::asio::basic_socket<Protocol, Executor>::shutdown(boost::asio::socket_base::shutdown_type, boost::system::error_code&) [with Protocol = boost::asio::ip::tcp; Executor = boost::asio::executor]’
 1685 |   BOOST_ASIO_SYNC_OP_VOID shutdown(shutdown_type what,
      |                             ^~~~~~~~
/usr/local/include/boost/asio/basic_socket.hpp:1686:34: note:   no known conversion for argument 2 from ‘boost::system::error_code*’ to ‘boost::system::error_code&’
 1686 |       boost::system::error_code& ec)
      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~^~
In file included from /usr/local/include/boost/asio/basic_socket_streambuf.hpp:25,
                 from /usr/local/include/boost/asio/basic_socket_iostream.hpp:24,
                 from /usr/local/include/boost/asio.hpp:33,
                 from cpp/Connection.cpp:2:
/usr/local/include/boost/asio/basic_stream_socket.hpp: In instantiation of ‘void boost::asio::basic_stream_socket<Protocol, Executor>::initiate_async_receive::operator()(ReadHandler&&, const MutableBufferSequence&, boost::asio::socket_base::message_flags) const [with ReadHandler = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; MutableBufferSequence = boost::asio::mutable_buffers_1; Protocol = boost::asio::ip::tcp; Executor = boost::asio::executor; boost::asio::socket_base::message_flags = int]’:
/usr/local/include/boost/asio/async_result.hpp:152:42:   required from ‘static boost::asio::async_result<CompletionToken, Signature>::return_type boost::asio::async_result<CompletionToken, Signature>::initiate(Initiation&&, RawCompletionToken&&, Args&& ...) [with Initiation = boost::asio::basic_stream_socket<boost::asio::ip::tcp>::initiate_async_receive; RawCompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; Args = {const boost::asio::mutable_buffers_1&, int}; CompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; Signature = void(boost::system::error_code, long unsigned int); boost::asio::async_result<CompletionToken, Signature>::return_type = void]’
/usr/local/include/boost/asio/async_result.hpp:365:25:   required from ‘typename std::enable_if<boost::asio::detail::async_result_has_initiate_memfn<CompletionToken, Signature>::value, decltype (boost::asio::async_result<typename std::decay<_Tp>::type, Signature>::initiate(declval<Initiation&&>(), declval<CompletionToken&&>(), (declval<Args&>)()...))>::type boost::asio::async_initiate(Initiation&&, CompletionToken&, Args&& ...) [with CompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; Signature = void(boost::system::error_code, long unsigned int); Initiation = boost::asio::basic_stream_socket<boost::asio::ip::tcp>::initiate_async_receive; Args = {const boost::asio::mutable_buffers_1&, int}; typename std::enable_if<boost::asio::detail::async_result_has_initiate_memfn<CompletionToken, Signature>::value, decltype (boost::asio::async_result<typename std::decay<_Tp>::type, Signature>::initiate(declval<Initiation&&>(), declval<CompletionToken&&>(), (declval<Args&>)()...))>::type = void]’
/usr/local/include/boost/asio/basic_stream_socket.hpp:971:53:   required from ‘auto boost::asio::basic_stream_socket<Protocol, Executor>::async_read_some(const MutableBufferSequence&, ReadHandler&&) [with MutableBufferSequence = boost::asio::mutable_buffers_1; ReadHandler = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; Protocol = boost::asio::ip::tcp; Executor = boost::asio::executor]’
cpp/Connection.cpp:48:2:   required from here
/usr/local/include/boost/asio/basic_stream_socket.hpp:1033:404: error: static assertion failed: ReadHandler type requirements not met
 1033 |       BOOST_ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
      |                                                                                                                                                                                                                                                                                                                                                                                                                    ^   
In file included from /usr/local/include/boost/asio.hpp:24,
                 from cpp/Connection.cpp:2:
/usr/local/include/boost/asio/basic_datagram_socket.hpp:1092:666: error: no match for call to ‘(std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>) (const boost::system::error_code&, const long unsigned int&)’
 1092 |       BOOST_ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^                                                                                                                
In file included from /usr/local/include/boost/system/error_code.hpp:19,
                 from /usr/local/include/boost/asio/detail/scheduler_operation.hpp:18,
                 from /usr/local/include/boost/asio/detail/executor_op.hpp:22,
                 from /usr/local/include/boost/asio/impl/system_executor.hpp:18,
                 from /usr/local/include/boost/asio/system_executor.hpp:129,
                 from /usr/local/include/boost/asio/associated_executor.hpp:21,
                 from /usr/local/include/boost/asio.hpp:21,
                 from cpp/Connection.cpp:2:
/usr/include/c++/9/functional:480:2: note: candidate: ‘template<class ... _Args, class _Result> _Result std::_Bind<_Functor(_Bound_args ...)>::operator()(_Args&& ...) [with _Args = {_Args ...}; _Result = _Result; _Functor = void (Connection::*)(const boost::system::error_code&, long unsigned int); _Bound_args = {std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()}]’
  480 |  operator()(_Args&&... __args)
      |  ^~~~~~~~
/usr/include/c++/9/functional:480:2: note:   template argument deduction/substitution failed:
/usr/include/c++/9/functional: In substitution of ‘template<class _Functor, class ... _Bound_args> template<class _Fn, class _CallArgs, class ... _BArgs> using _Res_type_impl = typename std::result_of<_Fn&(std::_Bind<_Functor(_Bound_args ...)>::_Mu_type<_BArgs, _CallArgs>&& ...)>::type [with _Fn = void (Connection::*)(const boost::system::error_code&, long unsigned int); _CallArgs = std::tuple<const boost::system::error_code&, const long unsigned int&>; _BArgs = {std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()}; _Functor = void (Connection::*)(const boost::system::error_code&, long unsigned int); _Bound_args = {std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()}]’:
/usr/include/c++/9/functional:447:8:   required by substitution of ‘template<class _Functor, class ... _Bound_args> template<class _CallArgs> using _Res_type = std::_Bind<_Functor(_Bound_args ...)>::_Res_type_impl<_Functor, _CallArgs, _Bound_args ...> [with _CallArgs = std::tuple<const boost::system::error_code&, const long unsigned int&>; _Functor = void (Connection::*)(const boost::system::error_code&, long unsigned int); _Bound_args = {std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()}]’
/usr/include/c++/9/functional:478:9:   required from ‘void boost::asio::basic_stream_socket<Protocol, Executor>::initiate_async_receive::operator()(ReadHandler&&, const MutableBufferSequence&, boost::asio::socket_base::message_flags) const [with ReadHandler = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; MutableBufferSequence = boost::asio::mutable_buffers_1; Protocol = boost::asio::ip::tcp; Executor = boost::asio::executor; boost::asio::socket_base::message_flags = int]’
/usr/local/include/boost/asio/async_result.hpp:152:42:   required from ‘static boost::asio::async_result<CompletionToken, Signature>::return_type boost::asio::async_result<CompletionToken, Signature>::initiate(Initiation&&, RawCompletionToken&&, Args&& ...) [with Initiation = boost::asio::basic_stream_socket<boost::asio::ip::tcp>::initiate_async_receive; RawCompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; Args = {const boost::asio::mutable_buffers_1&, int}; CompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; Signature = void(boost::system::error_code, long unsigned int); boost::asio::async_result<CompletionToken, Signature>::return_type = void]’
/usr/local/include/boost/asio/async_result.hpp:365:25:   required from ‘typename std::enable_if<boost::asio::detail::async_result_has_initiate_memfn<CompletionToken, Signature>::value, decltype (boost::asio::async_result<typename std::decay<_Tp>::type, Signature>::initiate(declval<Initiation&&>(), declval<CompletionToken&&>(), (declval<Args&>)()...))>::type boost::asio::async_initiate(Initiation&&, CompletionToken&, Args&& ...) [with CompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; Signature = void(boost::system::error_code, long unsigned int); Initiation = boost::asio::basic_stream_socket<boost::asio::ip::tcp>::initiate_async_receive; Args = {const boost::asio::mutable_buffers_1&, int}; typename std::enable_if<boost::asio::detail::async_result_has_initiate_memfn<CompletionToken, Signature>::value, decltype (boost::asio::async_result<typename std::decay<_Tp>::type, Signature>::initiate(declval<Initiation&&>(), declval<CompletionToken&&>(), (declval<Args&>)()...))>::type = void]’
/usr/local/include/boost/asio/basic_stream_socket.hpp:971:53:   required from ‘auto boost::asio::basic_stream_socket<Protocol, Executor>::async_read_some(const MutableBufferSequence&, ReadHandler&&) [with MutableBufferSequence = boost::asio::mutable_buffers_1; ReadHandler = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; Protocol = boost::asio::ip::tcp; Executor = boost::asio::executor]’
cpp/Connection.cpp:48:2:   required from here
/usr/include/c++/9/functional:443:8: error: no type named ‘type’ in ‘class std::result_of<void (Connection::*&(std::shared_ptr<Connection>&, boost::arg<1> (*&)(), boost::arg<2> (*&)()))(const boost::system::error_code&, long unsigned int)>’
  443 |  using _Res_type_impl
      |        ^~~~~~~~~~~~~~
/usr/local/include/boost/asio/basic_datagram_socket.hpp: In instantiation of ‘void boost::asio::basic_stream_socket<Protocol, Executor>::initiate_async_receive::operator()(ReadHandler&&, const MutableBufferSequence&, boost::asio::socket_base::message_flags) const [with ReadHandler = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; MutableBufferSequence = boost::asio::mutable_buffers_1; Protocol = boost::asio::ip::tcp; Executor = boost::asio::executor; boost::asio::socket_base::message_flags = int]’:
/usr/local/include/boost/asio/async_result.hpp:152:42:   required from ‘static boost::asio::async_result<CompletionToken, Signature>::return_type boost::asio::async_result<CompletionToken, Signature>::initiate(Initiation&&, RawCompletionToken&&, Args&& ...) [with Initiation = boost::asio::basic_stream_socket<boost::asio::ip::tcp>::initiate_async_receive; RawCompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; Args = {const boost::asio::mutable_buffers_1&, int}; CompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; Signature = void(boost::system::error_code, long unsigned int); boost::asio::async_result<CompletionToken, Signature>::return_type = void]’
/usr/local/include/boost/asio/async_result.hpp:365:25:   required from ‘typename std::enable_if<boost::asio::detail::async_result_has_initiate_memfn<CompletionToken, Signature>::value, decltype (boost::asio::async_result<typename std::decay<_Tp>::type, Signature>::initiate(declval<Initiation&&>(), declval<CompletionToken&&>(), (declval<Args&>)()...))>::type boost::asio::async_initiate(Initiation&&, CompletionToken&, Args&& ...) [with CompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; Signature = void(boost::system::error_code, long unsigned int); Initiation = boost::asio::basic_stream_socket<boost::asio::ip::tcp>::initiate_async_receive; Args = {const boost::asio::mutable_buffers_1&, int}; typename std::enable_if<boost::asio::detail::async_result_has_initiate_memfn<CompletionToken, Signature>::value, decltype (boost::asio::async_result<typename std::decay<_Tp>::type, Signature>::initiate(declval<Initiation&&>(), declval<CompletionToken&&>(), (declval<Args&>)()...))>::type = void]’
/usr/local/include/boost/asio/basic_stream_socket.hpp:971:53:   required from ‘auto boost::asio::basic_stream_socket<Protocol, Executor>::async_read_some(const MutableBufferSequence&, ReadHandler&&) [with MutableBufferSequence = boost::asio::mutable_buffers_1; ReadHandler = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; Protocol = boost::asio::ip::tcp; Executor = boost::asio::executor]’
cpp/Connection.cpp:48:2:   required from here
/usr/include/c++/9/functional:491:2: note: candidate: ‘template<class ... _Args, class _Result> _Result std::_Bind<_Functor(_Bound_args ...)>::operator()(_Args&& ...) const [with _Args = {_Args ...}; _Result = _Result; _Functor = void (Connection::*)(const boost::system::error_code&, long unsigned int); _Bound_args = {std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()}]’
  491 |  operator()(_Args&&... __args) const
      |  ^~~~~~~~
/usr/include/c++/9/functional:491:2: note:   template argument deduction/substitution failed:
/usr/include/c++/9/functional: In substitution of ‘template<class _Functor, class ... _Bound_args> template<class _Fn, class _CallArgs, class ... _BArgs> using _Res_type_impl = typename std::result_of<_Fn&(std::_Bind<_Functor(_Bound_args ...)>::_Mu_type<_BArgs, _CallArgs>&& ...)>::type [with _Fn = std::add_const<void (Connection::*)(const boost::system::error_code&, long unsigned int)>::type; _CallArgs = std::tuple<const boost::system::error_code&, const long unsigned int&>; _BArgs = {std::add_const<std::shared_ptr<Connection> >::type, std::add_const<boost::arg<1> (*)()>::type, std::add_const<boost::arg<2> (*)()>::type}; _Functor = void (Connection::*)(const boost::system::error_code&, long unsigned int); _Bound_args = {std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()}]’:
/usr/include/c++/9/functional:454:8:   required by substitution of ‘template<class _Functor, class ... _Bound_args> template<class _CallArgs, template<class _CallArgs, template<class> class __cv_quals> template<class _Functor, class ... _Bound_args> template<class> class __cv_quals> using _Res_type_cv = std::_Bind<_Functor(_Bound_args ...)>::_Res_type_impl<typename __cv_quals<typename std::enable_if<(bool)((std::tuple_size<_Tuple>::value + 1)), _Functor>::type>::type, _CallArgs, typename __cv_quals<_Bound_args>::type ...> [with _CallArgs = std::tuple<const boost::system::error_code&, const long unsigned int&>; __cv_quals = std::add_const; _Functor = void (Connection::*)(const boost::system::error_code&, long unsigned int); _Bound_args = {std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()}]’
/usr/include/c++/9/functional:489:9:   required from ‘void boost::asio::basic_stream_socket<Protocol, Executor>::initiate_async_receive::operator()(ReadHandler&&, const MutableBufferSequence&, boost::asio::socket_base::message_flags) const [with ReadHandler = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; MutableBufferSequence = boost::asio::mutable_buffers_1; Protocol = boost::asio::ip::tcp; Executor = boost::asio::executor; boost::asio::socket_base::message_flags = int]’
/usr/local/include/boost/asio/async_result.hpp:152:42:   required from ‘static boost::asio::async_result<CompletionToken, Signature>::return_type boost::asio::async_result<CompletionToken, Signature>::initiate(Initiation&&, RawCompletionToken&&, Args&& ...) [with Initiation = boost::asio::basic_stream_socket<boost::asio::ip::tcp>::initiate_async_receive; RawCompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; Args = {const boost::asio::mutable_buffers_1&, int}; CompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; Signature = void(boost::system::error_code, long unsigned int); boost::asio::async_result<CompletionToken, Signature>::return_type = void]’
/usr/local/include/boost/asio/async_result.hpp:365:25:   required from ‘typename std::enable_if<boost::asio::detail::async_result_has_initiate_memfn<CompletionToken, Signature>::value, decltype (boost::asio::async_result<typename std::decay<_Tp>::type, Signature>::initiate(declval<Initiation&&>(), declval<CompletionToken&&>(), (declval<Args&>)()...))>::type boost::asio::async_initiate(Initiation&&, CompletionToken&, Args&& ...) [with CompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; Signature = void(boost::system::error_code, long unsigned int); Initiation = boost::asio::basic_stream_socket<boost::asio::ip::tcp>::initiate_async_receive; Args = {const boost::asio::mutable_buffers_1&, int}; typename std::enable_if<boost::asio::detail::async_result_has_initiate_memfn<CompletionToken, Signature>::value, decltype (boost::asio::async_result<typename std::decay<_Tp>::type, Signature>::initiate(declval<Initiation&&>(), declval<CompletionToken&&>(), (declval<Args&>)()...))>::type = void]’
/usr/local/include/boost/asio/basic_stream_socket.hpp:971:53:   required from ‘auto boost::asio::basic_stream_socket<Protocol, Executor>::async_read_some(const MutableBufferSequence&, ReadHandler&&) [with MutableBufferSequence = boost::asio::mutable_buffers_1; ReadHandler = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; Protocol = boost::asio::ip::tcp; Executor = boost::asio::executor]’
cpp/Connection.cpp:48:2:   required from here
/usr/include/c++/9/functional:443:8: error: no type named ‘type’ in ‘class std::result_of<void (Connection::* const&(const std::shared_ptr<Connection>&, boost::arg<1> (* const&)(), boost::arg<2> (* const&)()))(const boost::system::error_code&, long unsigned int)>’
  443 |  using _Res_type_impl
      |        ^~~~~~~~~~~~~~
/usr/local/include/boost/asio/basic_datagram_socket.hpp: In instantiation of ‘void boost::asio::basic_stream_socket<Protocol, Executor>::initiate_async_receive::operator()(ReadHandler&&, const MutableBufferSequence&, boost::asio::socket_base::message_flags) const [with ReadHandler = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; MutableBufferSequence = boost::asio::mutable_buffers_1; Protocol = boost::asio::ip::tcp; Executor = boost::asio::executor; boost::asio::socket_base::message_flags = int]’:
/usr/local/include/boost/asio/async_result.hpp:152:42:   required from ‘static boost::asio::async_result<CompletionToken, Signature>::return_type boost::asio::async_result<CompletionToken, Signature>::initiate(Initiation&&, RawCompletionToken&&, Args&& ...) [with Initiation = boost::asio::basic_stream_socket<boost::asio::ip::tcp>::initiate_async_receive; RawCompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; Args = {const boost::asio::mutable_buffers_1&, int}; CompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; Signature = void(boost::system::error_code, long unsigned int); boost::asio::async_result<CompletionToken, Signature>::return_type = void]’
/usr/local/include/boost/asio/async_result.hpp:365:25:   required from ‘typename std::enable_if<boost::asio::detail::async_result_has_initiate_memfn<CompletionToken, Signature>::value, decltype (boost::asio::async_result<typename std::decay<_Tp>::type, Signature>::initiate(declval<Initiation&&>(), declval<CompletionToken&&>(), (declval<Args&>)()...))>::type boost::asio::async_initiate(Initiation&&, CompletionToken&, Args&& ...) [with CompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; Signature = void(boost::system::error_code, long unsigned int); Initiation = boost::asio::basic_stream_socket<boost::asio::ip::tcp>::initiate_async_receive; Args = {const boost::asio::mutable_buffers_1&, int}; typename std::enable_if<boost::asio::detail::async_result_has_initiate_memfn<CompletionToken, Signature>::value, decltype (boost::asio::async_result<typename std::decay<_Tp>::type, Signature>::initiate(declval<Initiation&&>(), declval<CompletionToken&&>(), (declval<Args&>)()...))>::type = void]’
/usr/local/include/boost/asio/basic_stream_socket.hpp:971:53:   required from ‘auto boost::asio::basic_stream_socket<Protocol, Executor>::async_read_some(const MutableBufferSequence&, ReadHandler&&) [with MutableBufferSequence = boost::asio::mutable_buffers_1; ReadHandler = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; Protocol = boost::asio::ip::tcp; Executor = boost::asio::executor]’
cpp/Connection.cpp:48:2:   required from here
/usr/include/c++/9/functional:509:2: note: candidate: ‘template<class ... _Args, class _Result> _Result std::_Bind<_Functor(_Bound_args ...)>::operator()(_Args&& ...) volatile [with _Args = {_Args ...}; _Result = _Result; _Functor = void (Connection::*)(const boost::system::error_code&, long unsigned int); _Bound_args = {std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()}]’
  509 |  operator()(_Args&&... __args) volatile
      |  ^~~~~~~~
/usr/include/c++/9/functional:509:2: note:   template argument deduction/substitution failed:
/usr/include/c++/9/functional: In substitution of ‘template<class _Functor, class ... _Bound_args> template<class _Fn, class _CallArgs, class ... _BArgs> using _Res_type_impl = typename std::result_of<_Fn&(std::_Bind<_Functor(_Bound_args ...)>::_Mu_type<_BArgs, _CallArgs>&& ...)>::type [with _Fn = std::add_volatile<void (Connection::*)(const boost::system::error_code&, long unsigned int)>::type; _CallArgs = std::tuple<const boost::system::error_code&, const long unsigned int&>; _BArgs = {std::add_volatile<std::shared_ptr<Connection> >::type, std::add_volatile<boost::arg<1> (*)()>::type, std::add_volatile<boost::arg<2> (*)()>::type}; _Functor = void (Connection::*)(const boost::system::error_code&, long unsigned int); _Bound_args = {std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()}]’:
/usr/include/c++/9/functional:454:8:   required by substitution of ‘template<class _Functor, class ... _Bound_args> template<class _CallArgs, template<class _CallArgs, template<class> class __cv_quals> template<class _Functor, class ... _Bound_args> template<class> class __cv_quals> using _Res_type_cv = std::_Bind<_Functor(_Bound_args ...)>::_Res_type_impl<typename __cv_quals<typename std::enable_if<(bool)((std::tuple_size<_Tuple>::value + 1)), _Functor>::type>::type, _CallArgs, typename __cv_quals<_Bound_args>::type ...> [with _CallArgs = std::tuple<const boost::system::error_code&, const long unsigned int&>; __cv_quals = std::add_volatile; _Functor = void (Connection::*)(const boost::system::error_code&, long unsigned int); _Bound_args = {std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()}]’
/usr/include/c++/9/functional:506:9:   required from ‘void boost::asio::basic_stream_socket<Protocol, Executor>::initiate_async_receive::operator()(ReadHandler&&, const MutableBufferSequence&, boost::asio::socket_base::message_flags) const [with ReadHandler = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; MutableBufferSequence = boost::asio::mutable_buffers_1; Protocol = boost::asio::ip::tcp; Executor = boost::asio::executor; boost::asio::socket_base::message_flags = int]’
/usr/local/include/boost/asio/async_result.hpp:152:42:   required from ‘static boost::asio::async_result<CompletionToken, Signature>::return_type boost::asio::async_result<CompletionToken, Signature>::initiate(Initiation&&, RawCompletionToken&&, Args&& ...) [with Initiation = boost::asio::basic_stream_socket<boost::asio::ip::tcp>::initiate_async_receive; RawCompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; Args = {const boost::asio::mutable_buffers_1&, int}; CompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; Signature = void(boost::system::error_code, long unsigned int); boost::asio::async_result<CompletionToken, Signature>::return_type = void]’
/usr/local/include/boost/asio/async_result.hpp:365:25:   required from ‘typename std::enable_if<boost::asio::detail::async_result_has_initiate_memfn<CompletionToken, Signature>::value, decltype (boost::asio::async_result<typename std::decay<_Tp>::type, Signature>::initiate(declval<Initiation&&>(), declval<CompletionToken&&>(), (declval<Args&>)()...))>::type boost::asio::async_initiate(Initiation&&, CompletionToken&, Args&& ...) [with CompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; Signature = void(boost::system::error_code, long unsigned int); Initiation = boost::asio::basic_stream_socket<boost::asio::ip::tcp>::initiate_async_receive; Args = {const boost::asio::mutable_buffers_1&, int}; typename std::enable_if<boost::asio::detail::async_result_has_initiate_memfn<CompletionToken, Signature>::value, decltype (boost::asio::async_result<typename std::decay<_Tp>::type, Signature>::initiate(declval<Initiation&&>(), declval<CompletionToken&&>(), (declval<Args&>)()...))>::type = void]’
/usr/local/include/boost/asio/basic_stream_socket.hpp:971:53:   required from ‘auto boost::asio::basic_stream_socket<Protocol, Executor>::async_read_some(const MutableBufferSequence&, ReadHandler&&) [with MutableBufferSequence = boost::asio::mutable_buffers_1; ReadHandler = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; Protocol = boost::asio::ip::tcp; Executor = boost::asio::executor]’
cpp/Connection.cpp:48:2:   required from here
/usr/include/c++/9/functional:443:8: error: no type named ‘type’ in ‘class std::result_of<void (Connection::* volatile&(volatile std::shared_ptr<Connection>&, boost::arg<1> (* volatile&)(), boost::arg<2> (* volatile&)()))(const boost::system::error_code&, long unsigned int)>’
  443 |  using _Res_type_impl
      |        ^~~~~~~~~~~~~~
/usr/local/include/boost/asio/basic_datagram_socket.hpp: In instantiation of ‘void boost::asio::basic_stream_socket<Protocol, Executor>::initiate_async_receive::operator()(ReadHandler&&, const MutableBufferSequence&, boost::asio::socket_base::message_flags) const [with ReadHandler = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; MutableBufferSequence = boost::asio::mutable_buffers_1; Protocol = boost::asio::ip::tcp; Executor = boost::asio::executor; boost::asio::socket_base::message_flags = int]’:
/usr/local/include/boost/asio/async_result.hpp:152:42:   required from ‘static boost::asio::async_result<CompletionToken, Signature>::return_type boost::asio::async_result<CompletionToken, Signature>::initiate(Initiation&&, RawCompletionToken&&, Args&& ...) [with Initiation = boost::asio::basic_stream_socket<boost::asio::ip::tcp>::initiate_async_receive; RawCompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; Args = {const boost::asio::mutable_buffers_1&, int}; CompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; Signature = void(boost::system::error_code, long unsigned int); boost::asio::async_result<CompletionToken, Signature>::return_type = void]’
/usr/local/include/boost/asio/async_result.hpp:365:25:   required from ‘typename std::enable_if<boost::asio::detail::async_result_has_initiate_memfn<CompletionToken, Signature>::value, decltype (boost::asio::async_result<typename std::decay<_Tp>::type, Signature>::initiate(declval<Initiation&&>(), declval<CompletionToken&&>(), (declval<Args&>)()...))>::type boost::asio::async_initiate(Initiation&&, CompletionToken&, Args&& ...) [with CompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; Signature = void(boost::system::error_code, long unsigned int); Initiation = boost::asio::basic_stream_socket<boost::asio::ip::tcp>::initiate_async_receive; Args = {const boost::asio::mutable_buffers_1&, int}; typename std::enable_if<boost::asio::detail::async_result_has_initiate_memfn<CompletionToken, Signature>::value, decltype (boost::asio::async_result<typename std::decay<_Tp>::type, Signature>::initiate(declval<Initiation&&>(), declval<CompletionToken&&>(), (declval<Args&>)()...))>::type = void]’
/usr/local/include/boost/asio/basic_stream_socket.hpp:971:53:   required from ‘auto boost::asio::basic_stream_socket<Protocol, Executor>::async_read_some(const MutableBufferSequence&, ReadHandler&&) [with MutableBufferSequence = boost::asio::mutable_buffers_1; ReadHandler = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; Protocol = boost::asio::ip::tcp; Executor = boost::asio::executor]’
cpp/Connection.cpp:48:2:   required from here
/usr/include/c++/9/functional:521:2: note: candidate: ‘template<class ... _Args, class _Result> _Result std::_Bind<_Functor(_Bound_args ...)>::operator()(_Args&& ...) const volatile [with _Args = {_Args ...}; _Result = _Result; _Functor = void (Connection::*)(const boost::system::error_code&, long unsigned int); _Bound_args = {std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()}]’
  521 |  operator()(_Args&&... __args) const volatile
      |  ^~~~~~~~
/usr/include/c++/9/functional:521:2: note:   template argument deduction/substitution failed:
/usr/include/c++/9/functional: In substitution of ‘template<class _Functor, class ... _Bound_args> template<class _Fn, class _CallArgs, class ... _BArgs> using _Res_type_impl = typename std::result_of<_Fn&(std::_Bind<_Functor(_Bound_args ...)>::_Mu_type<_BArgs, _CallArgs>&& ...)>::type [with _Fn = std::add_cv<void (Connection::*)(const boost::system::error_code&, long unsigned int)>::type; _CallArgs = std::tuple<const boost::system::error_code&, const long unsigned int&>; _BArgs = {std::add_cv<std::shared_ptr<Connection> >::type, std::add_cv<boost::arg<1> (*)()>::type, std::add_cv<boost::arg<2> (*)()>::type}; _Functor = void (Connection::*)(const boost::system::error_code&, long unsigned int); _Bound_args = {std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()}]’:
/usr/include/c++/9/functional:454:8:   required by substitution of ‘template<class _Functor, class ... _Bound_args> template<class _CallArgs, template<class _CallArgs, template<class> class __cv_quals> template<class _Functor, class ... _Bound_args> template<class> class __cv_quals> using _Res_type_cv = std::_Bind<_Functor(_Bound_args ...)>::_Res_type_impl<typename __cv_quals<typename std::enable_if<(bool)((std::tuple_size<_Tuple>::value + 1)), _Functor>::type>::type, _CallArgs, typename __cv_quals<_Bound_args>::type ...> [with _CallArgs = std::tuple<const boost::system::error_code&, const long unsigned int&>; __cv_quals = std::add_cv; _Functor = void (Connection::*)(const boost::system::error_code&, long unsigned int); _Bound_args = {std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()}]’
/usr/include/c++/9/functional:518:9:   required from ‘void boost::asio::basic_stream_socket<Protocol, Executor>::initiate_async_receive::operator()(ReadHandler&&, const MutableBufferSequence&, boost::asio::socket_base::message_flags) const [with ReadHandler = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; MutableBufferSequence = boost::asio::mutable_buffers_1; Protocol = boost::asio::ip::tcp; Executor = boost::asio::executor; boost::asio::socket_base::message_flags = int]’
/usr/local/include/boost/asio/async_result.hpp:152:42:   required from ‘static boost::asio::async_result<CompletionToken, Signature>::return_type boost::asio::async_result<CompletionToken, Signature>::initiate(Initiation&&, RawCompletionToken&&, Args&& ...) [with Initiation = boost::asio::basic_stream_socket<boost::asio::ip::tcp>::initiate_async_receive; RawCompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; Args = {const boost::asio::mutable_buffers_1&, int}; CompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; Signature = void(boost::system::error_code, long unsigned int); boost::asio::async_result<CompletionToken, Signature>::return_type = void]’
/usr/local/include/boost/asio/async_result.hpp:365:25:   required from ‘typename std::enable_if<boost::asio::detail::async_result_has_initiate_memfn<CompletionToken, Signature>::value, decltype (boost::asio::async_result<typename std::decay<_Tp>::type, Signature>::initiate(declval<Initiation&&>(), declval<CompletionToken&&>(), (declval<Args&>)()...))>::type boost::asio::async_initiate(Initiation&&, CompletionToken&, Args&& ...) [with CompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; Signature = void(boost::system::error_code, long unsigned int); Initiation = boost::asio::basic_stream_socket<boost::asio::ip::tcp>::initiate_async_receive; Args = {const boost::asio::mutable_buffers_1&, int}; typename std::enable_if<boost::asio::detail::async_result_has_initiate_memfn<CompletionToken, Signature>::value, decltype (boost::asio::async_result<typename std::decay<_Tp>::type, Signature>::initiate(declval<Initiation&&>(), declval<CompletionToken&&>(), (declval<Args&>)()...))>::type = void]’
/usr/local/include/boost/asio/basic_stream_socket.hpp:971:53:   required from ‘auto boost::asio::basic_stream_socket<Protocol, Executor>::async_read_some(const MutableBufferSequence&, ReadHandler&&) [with MutableBufferSequence = boost::asio::mutable_buffers_1; ReadHandler = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)(), boost::arg<2> (*)()))(const boost::system::error_code&, long unsigned int)>; Protocol = boost::asio::ip::tcp; Executor = boost::asio::executor]’
cpp/Connection.cpp:48:2:   required from here
/usr/include/c++/9/functional:443:8: error: no type named ‘type’ in ‘class std::result_of<void (Connection::* const volatile&(const volatile std::shared_ptr<Connection>&, boost::arg<1> (* const volatile&)(), boost::arg<2> (* const volatile&)()))(const boost::system::error_code&, long unsigned int)>’
  443 |  using _Res_type_impl
      |        ^~~~~~~~~~~~~~
In file included from /usr/local/include/boost/asio/write.hpp:1246,
                 from /usr/local/include/boost/asio/buffered_write_stream.hpp:28,
                 from /usr/local/include/boost/asio/buffered_stream.hpp:22,
                 from /usr/local/include/boost/asio.hpp:43,
                 from cpp/Connection.cpp:2:
/usr/local/include/boost/asio/impl/write.hpp: In instantiation of ‘void boost::asio::detail::initiate_async_write_buffer_sequence<AsyncWriteStream>::operator()(WriteHandler&&, const ConstBufferSequence&, CompletionCondition&&) const [with WriteHandler = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; ConstBufferSequence = std::vector<boost::asio::const_buffer>; CompletionCondition = boost::asio::detail::transfer_all_t; AsyncWriteStream = boost::asio::basic_stream_socket<boost::asio::ip::tcp>]’:
/usr/local/include/boost/asio/async_result.hpp:152:42:   required from ‘static boost::asio::async_result<CompletionToken, Signature>::return_type boost::asio::async_result<CompletionToken, Signature>::initiate(Initiation&&, RawCompletionToken&&, Args&& ...) [with Initiation = boost::asio::detail::initiate_async_write_buffer_sequence<boost::asio::basic_stream_socket<boost::asio::ip::tcp> >; RawCompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; Args = {const std::vector<boost::asio::const_buffer, std::allocator<boost::asio::const_buffer> >&, boost::asio::detail::transfer_all_t}; CompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; Signature = void(boost::system::error_code, long unsigned int); boost::asio::async_result<CompletionToken, Signature>::return_type = void]’
/usr/local/include/boost/asio/async_result.hpp:365:25:   required from ‘typename std::enable_if<boost::asio::detail::async_result_has_initiate_memfn<CompletionToken, Signature>::value, decltype (boost::asio::async_result<typename std::decay<_Tp>::type, Signature>::initiate(declval<Initiation&&>(), declval<CompletionToken&&>(), (declval<Args&>)()...))>::type boost::asio::async_initiate(Initiation&&, CompletionToken&, Args&& ...) [with CompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; Signature = void(boost::system::error_code, long unsigned int); Initiation = boost::asio::detail::initiate_async_write_buffer_sequence<boost::asio::basic_stream_socket<boost::asio::ip::tcp> >; Args = {const std::vector<boost::asio::const_buffer, std::allocator<boost::asio::const_buffer> >&, boost::asio::detail::transfer_all_t}; typename std::enable_if<boost::asio::detail::async_result_has_initiate_memfn<CompletionToken, Signature>::value, decltype (boost::asio::async_result<typename std::decay<_Tp>::type, Signature>::initiate(declval<Initiation&&>(), declval<CompletionToken&&>(), (declval<Args&>)()...))>::type = void]’
/usr/local/include/boost/asio/impl/write.hpp:533:51:   required from ‘auto boost::asio::async_write(AsyncWriteStream&, const ConstBufferSequence&, WriteHandler&&, typename std::enable_if<boost::asio::is_const_buffer_sequence<ConstBufferSequence>::value>::type*) [with AsyncWriteStream = boost::asio::basic_stream_socket<boost::asio::ip::tcp>; ConstBufferSequence = std::vector<boost::asio::const_buffer>; WriteHandler = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; typename std::enable_if<boost::asio::is_const_buffer_sequence<ConstBufferSequence>::value>::type = void]’
cpp/Connection.cpp:79:4:   required from here
/usr/local/include/boost/asio/impl/write.hpp:445:405: error: static assertion failed: WriteHandler type requirements not met
  445 |       BOOST_ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
      |                                                                                                                                                                                                                                                                                                                                                                                                                     ^   
In file included from /usr/local/include/boost/asio.hpp:24,
                 from cpp/Connection.cpp:2:
/usr/local/include/boost/asio/basic_datagram_socket.hpp:1092:666: error: no match for call to ‘(std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>) (const boost::system::error_code&, const long unsigned int&)’
 1092 |       BOOST_ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^                                                                                                                
In file included from /usr/local/include/boost/system/error_code.hpp:19,
                 from /usr/local/include/boost/asio/detail/scheduler_operation.hpp:18,
                 from /usr/local/include/boost/asio/detail/executor_op.hpp:22,
                 from /usr/local/include/boost/asio/impl/system_executor.hpp:18,
                 from /usr/local/include/boost/asio/system_executor.hpp:129,
                 from /usr/local/include/boost/asio/associated_executor.hpp:21,
                 from /usr/local/include/boost/asio.hpp:21,
                 from cpp/Connection.cpp:2:
/usr/include/c++/9/functional:480:2: note: candidate: ‘template<class ... _Args, class _Result> _Result std::_Bind<_Functor(_Bound_args ...)>::operator()(_Args&& ...) [with _Args = {_Args ...}; _Result = _Result; _Functor = void (Connection::*)(const boost::system::error_code&); _Bound_args = {std::shared_ptr<Connection>, boost::arg<1> (*)()}]’
  480 |  operator()(_Args&&... __args)
      |  ^~~~~~~~
/usr/include/c++/9/functional:480:2: note:   template argument deduction/substitution failed:
/usr/include/c++/9/functional: In substitution of ‘template<class _Functor, class ... _Bound_args> template<class _Fn, class _CallArgs, class ... _BArgs> using _Res_type_impl = typename std::result_of<_Fn&(std::_Bind<_Functor(_Bound_args ...)>::_Mu_type<_BArgs, _CallArgs>&& ...)>::type [with _Fn = void (Connection::*)(const boost::system::error_code&); _CallArgs = std::tuple<const boost::system::error_code&, const long unsigned int&>; _BArgs = {std::shared_ptr<Connection>, boost::arg<1> (*)()}; _Functor = void (Connection::*)(const boost::system::error_code&); _Bound_args = {std::shared_ptr<Connection>, boost::arg<1> (*)()}]’:
/usr/include/c++/9/functional:447:8:   required by substitution of ‘template<class _Functor, class ... _Bound_args> template<class _CallArgs> using _Res_type = std::_Bind<_Functor(_Bound_args ...)>::_Res_type_impl<_Functor, _CallArgs, _Bound_args ...> [with _CallArgs = std::tuple<const boost::system::error_code&, const long unsigned int&>; _Functor = void (Connection::*)(const boost::system::error_code&); _Bound_args = {std::shared_ptr<Connection>, boost::arg<1> (*)()}]’
/usr/include/c++/9/functional:478:9:   required from ‘void boost::asio::detail::initiate_async_write_buffer_sequence<AsyncWriteStream>::operator()(WriteHandler&&, const ConstBufferSequence&, CompletionCondition&&) const [with WriteHandler = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; ConstBufferSequence = std::vector<boost::asio::const_buffer>; CompletionCondition = boost::asio::detail::transfer_all_t; AsyncWriteStream = boost::asio::basic_stream_socket<boost::asio::ip::tcp>]’
/usr/local/include/boost/asio/async_result.hpp:152:42:   required from ‘static boost::asio::async_result<CompletionToken, Signature>::return_type boost::asio::async_result<CompletionToken, Signature>::initiate(Initiation&&, RawCompletionToken&&, Args&& ...) [with Initiation = boost::asio::detail::initiate_async_write_buffer_sequence<boost::asio::basic_stream_socket<boost::asio::ip::tcp> >; RawCompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; Args = {const std::vector<boost::asio::const_buffer, std::allocator<boost::asio::const_buffer> >&, boost::asio::detail::transfer_all_t}; CompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; Signature = void(boost::system::error_code, long unsigned int); boost::asio::async_result<CompletionToken, Signature>::return_type = void]’
/usr/local/include/boost/asio/async_result.hpp:365:25:   required from ‘typename std::enable_if<boost::asio::detail::async_result_has_initiate_memfn<CompletionToken, Signature>::value, decltype (boost::asio::async_result<typename std::decay<_Tp>::type, Signature>::initiate(declval<Initiation&&>(), declval<CompletionToken&&>(), (declval<Args&>)()...))>::type boost::asio::async_initiate(Initiation&&, CompletionToken&, Args&& ...) [with CompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; Signature = void(boost::system::error_code, long unsigned int); Initiation = boost::asio::detail::initiate_async_write_buffer_sequence<boost::asio::basic_stream_socket<boost::asio::ip::tcp> >; Args = {const std::vector<boost::asio::const_buffer, std::allocator<boost::asio::const_buffer> >&, boost::asio::detail::transfer_all_t}; typename std::enable_if<boost::asio::detail::async_result_has_initiate_memfn<CompletionToken, Signature>::value, decltype (boost::asio::async_result<typename std::decay<_Tp>::type, Signature>::initiate(declval<Initiation&&>(), declval<CompletionToken&&>(), (declval<Args&>)()...))>::type = void]’
/usr/local/include/boost/asio/impl/write.hpp:533:51:   required from ‘auto boost::asio::async_write(AsyncWriteStream&, const ConstBufferSequence&, WriteHandler&&, typename std::enable_if<boost::asio::is_const_buffer_sequence<ConstBufferSequence>::value>::type*) [with AsyncWriteStream = boost::asio::basic_stream_socket<boost::asio::ip::tcp>; ConstBufferSequence = std::vector<boost::asio::const_buffer>; WriteHandler = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; typename std::enable_if<boost::asio::is_const_buffer_sequence<ConstBufferSequence>::value>::type = void]’
cpp/Connection.cpp:79:4:   required from here
/usr/include/c++/9/functional:443:8: error: no type named ‘type’ in ‘class std::result_of<void (Connection::*&(std::shared_ptr<Connection>&, boost::arg<1> (*&)()))(const boost::system::error_code&)>’
  443 |  using _Res_type_impl
      |        ^~~~~~~~~~~~~~
/usr/local/include/boost/asio/basic_datagram_socket.hpp: In instantiation of ‘void boost::asio::detail::initiate_async_write_buffer_sequence<AsyncWriteStream>::operator()(WriteHandler&&, const ConstBufferSequence&, CompletionCondition&&) const [with WriteHandler = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; ConstBufferSequence = std::vector<boost::asio::const_buffer>; CompletionCondition = boost::asio::detail::transfer_all_t; AsyncWriteStream = boost::asio::basic_stream_socket<boost::asio::ip::tcp>]’:
/usr/local/include/boost/asio/async_result.hpp:152:42:   required from ‘static boost::asio::async_result<CompletionToken, Signature>::return_type boost::asio::async_result<CompletionToken, Signature>::initiate(Initiation&&, RawCompletionToken&&, Args&& ...) [with Initiation = boost::asio::detail::initiate_async_write_buffer_sequence<boost::asio::basic_stream_socket<boost::asio::ip::tcp> >; RawCompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; Args = {const std::vector<boost::asio::const_buffer, std::allocator<boost::asio::const_buffer> >&, boost::asio::detail::transfer_all_t}; CompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; Signature = void(boost::system::error_code, long unsigned int); boost::asio::async_result<CompletionToken, Signature>::return_type = void]’
/usr/local/include/boost/asio/async_result.hpp:365:25:   required from ‘typename std::enable_if<boost::asio::detail::async_result_has_initiate_memfn<CompletionToken, Signature>::value, decltype (boost::asio::async_result<typename std::decay<_Tp>::type, Signature>::initiate(declval<Initiation&&>(), declval<CompletionToken&&>(), (declval<Args&>)()...))>::type boost::asio::async_initiate(Initiation&&, CompletionToken&, Args&& ...) [with CompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; Signature = void(boost::system::error_code, long unsigned int); Initiation = boost::asio::detail::initiate_async_write_buffer_sequence<boost::asio::basic_stream_socket<boost::asio::ip::tcp> >; Args = {const std::vector<boost::asio::const_buffer, std::allocator<boost::asio::const_buffer> >&, boost::asio::detail::transfer_all_t}; typename std::enable_if<boost::asio::detail::async_result_has_initiate_memfn<CompletionToken, Signature>::value, decltype (boost::asio::async_result<typename std::decay<_Tp>::type, Signature>::initiate(declval<Initiation&&>(), declval<CompletionToken&&>(), (declval<Args&>)()...))>::type = void]’
/usr/local/include/boost/asio/impl/write.hpp:533:51:   required from ‘auto boost::asio::async_write(AsyncWriteStream&, const ConstBufferSequence&, WriteHandler&&, typename std::enable_if<boost::asio::is_const_buffer_sequence<ConstBufferSequence>::value>::type*) [with AsyncWriteStream = boost::asio::basic_stream_socket<boost::asio::ip::tcp>; ConstBufferSequence = std::vector<boost::asio::const_buffer>; WriteHandler = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; typename std::enable_if<boost::asio::is_const_buffer_sequence<ConstBufferSequence>::value>::type = void]’
cpp/Connection.cpp:79:4:   required from here
/usr/include/c++/9/functional:491:2: note: candidate: ‘template<class ... _Args, class _Result> _Result std::_Bind<_Functor(_Bound_args ...)>::operator()(_Args&& ...) const [with _Args = {_Args ...}; _Result = _Result; _Functor = void (Connection::*)(const boost::system::error_code&); _Bound_args = {std::shared_ptr<Connection>, boost::arg<1> (*)()}]’
  491 |  operator()(_Args&&... __args) const
      |  ^~~~~~~~
/usr/include/c++/9/functional:491:2: note:   template argument deduction/substitution failed:
/usr/include/c++/9/functional: In substitution of ‘template<class _Functor, class ... _Bound_args> template<class _Fn, class _CallArgs, class ... _BArgs> using _Res_type_impl = typename std::result_of<_Fn&(std::_Bind<_Functor(_Bound_args ...)>::_Mu_type<_BArgs, _CallArgs>&& ...)>::type [with _Fn = std::add_const<void (Connection::*)(const boost::system::error_code&)>::type; _CallArgs = std::tuple<const boost::system::error_code&, const long unsigned int&>; _BArgs = {std::add_const<std::shared_ptr<Connection> >::type, std::add_const<boost::arg<1> (*)()>::type}; _Functor = void (Connection::*)(const boost::system::error_code&); _Bound_args = {std::shared_ptr<Connection>, boost::arg<1> (*)()}]’:
/usr/include/c++/9/functional:454:8:   required by substitution of ‘template<class _Functor, class ... _Bound_args> template<class _CallArgs, template<class _CallArgs, template<class> class __cv_quals> template<class _Functor, class ... _Bound_args> template<class> class __cv_quals> using _Res_type_cv = std::_Bind<_Functor(_Bound_args ...)>::_Res_type_impl<typename __cv_quals<typename std::enable_if<(bool)((std::tuple_size<_Tuple>::value + 1)), _Functor>::type>::type, _CallArgs, typename __cv_quals<_Bound_args>::type ...> [with _CallArgs = std::tuple<const boost::system::error_code&, const long unsigned int&>; __cv_quals = std::add_const; _Functor = void (Connection::*)(const boost::system::error_code&); _Bound_args = {std::shared_ptr<Connection>, boost::arg<1> (*)()}]’
/usr/include/c++/9/functional:489:9:   required from ‘void boost::asio::detail::initiate_async_write_buffer_sequence<AsyncWriteStream>::operator()(WriteHandler&&, const ConstBufferSequence&, CompletionCondition&&) const [with WriteHandler = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; ConstBufferSequence = std::vector<boost::asio::const_buffer>; CompletionCondition = boost::asio::detail::transfer_all_t; AsyncWriteStream = boost::asio::basic_stream_socket<boost::asio::ip::tcp>]’
/usr/local/include/boost/asio/async_result.hpp:152:42:   required from ‘static boost::asio::async_result<CompletionToken, Signature>::return_type boost::asio::async_result<CompletionToken, Signature>::initiate(Initiation&&, RawCompletionToken&&, Args&& ...) [with Initiation = boost::asio::detail::initiate_async_write_buffer_sequence<boost::asio::basic_stream_socket<boost::asio::ip::tcp> >; RawCompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; Args = {const std::vector<boost::asio::const_buffer, std::allocator<boost::asio::const_buffer> >&, boost::asio::detail::transfer_all_t}; CompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; Signature = void(boost::system::error_code, long unsigned int); boost::asio::async_result<CompletionToken, Signature>::return_type = void]’
/usr/local/include/boost/asio/async_result.hpp:365:25:   required from ‘typename std::enable_if<boost::asio::detail::async_result_has_initiate_memfn<CompletionToken, Signature>::value, decltype (boost::asio::async_result<typename std::decay<_Tp>::type, Signature>::initiate(declval<Initiation&&>(), declval<CompletionToken&&>(), (declval<Args&>)()...))>::type boost::asio::async_initiate(Initiation&&, CompletionToken&, Args&& ...) [with CompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; Signature = void(boost::system::error_code, long unsigned int); Initiation = boost::asio::detail::initiate_async_write_buffer_sequence<boost::asio::basic_stream_socket<boost::asio::ip::tcp> >; Args = {const std::vector<boost::asio::const_buffer, std::allocator<boost::asio::const_buffer> >&, boost::asio::detail::transfer_all_t}; typename std::enable_if<boost::asio::detail::async_result_has_initiate_memfn<CompletionToken, Signature>::value, decltype (boost::asio::async_result<typename std::decay<_Tp>::type, Signature>::initiate(declval<Initiation&&>(), declval<CompletionToken&&>(), (declval<Args&>)()...))>::type = void]’
/usr/local/include/boost/asio/impl/write.hpp:533:51:   required from ‘auto boost::asio::async_write(AsyncWriteStream&, const ConstBufferSequence&, WriteHandler&&, typename std::enable_if<boost::asio::is_const_buffer_sequence<ConstBufferSequence>::value>::type*) [with AsyncWriteStream = boost::asio::basic_stream_socket<boost::asio::ip::tcp>; ConstBufferSequence = std::vector<boost::asio::const_buffer>; WriteHandler = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; typename std::enable_if<boost::asio::is_const_buffer_sequence<ConstBufferSequence>::value>::type = void]’
cpp/Connection.cpp:79:4:   required from here
/usr/include/c++/9/functional:443:8: error: no type named ‘type’ in ‘class std::result_of<void (Connection::* const&(const std::shared_ptr<Connection>&, boost::arg<1> (* const&)()))(const boost::system::error_code&)>’
  443 |  using _Res_type_impl
      |        ^~~~~~~~~~~~~~
/usr/local/include/boost/asio/basic_datagram_socket.hpp: In instantiation of ‘void boost::asio::detail::initiate_async_write_buffer_sequence<AsyncWriteStream>::operator()(WriteHandler&&, const ConstBufferSequence&, CompletionCondition&&) const [with WriteHandler = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; ConstBufferSequence = std::vector<boost::asio::const_buffer>; CompletionCondition = boost::asio::detail::transfer_all_t; AsyncWriteStream = boost::asio::basic_stream_socket<boost::asio::ip::tcp>]’:
/usr/local/include/boost/asio/async_result.hpp:152:42:   required from ‘static boost::asio::async_result<CompletionToken, Signature>::return_type boost::asio::async_result<CompletionToken, Signature>::initiate(Initiation&&, RawCompletionToken&&, Args&& ...) [with Initiation = boost::asio::detail::initiate_async_write_buffer_sequence<boost::asio::basic_stream_socket<boost::asio::ip::tcp> >; RawCompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; Args = {const std::vector<boost::asio::const_buffer, std::allocator<boost::asio::const_buffer> >&, boost::asio::detail::transfer_all_t}; CompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; Signature = void(boost::system::error_code, long unsigned int); boost::asio::async_result<CompletionToken, Signature>::return_type = void]’
/usr/local/include/boost/asio/async_result.hpp:365:25:   required from ‘typename std::enable_if<boost::asio::detail::async_result_has_initiate_memfn<CompletionToken, Signature>::value, decltype (boost::asio::async_result<typename std::decay<_Tp>::type, Signature>::initiate(declval<Initiation&&>(), declval<CompletionToken&&>(), (declval<Args&>)()...))>::type boost::asio::async_initiate(Initiation&&, CompletionToken&, Args&& ...) [with CompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; Signature = void(boost::system::error_code, long unsigned int); Initiation = boost::asio::detail::initiate_async_write_buffer_sequence<boost::asio::basic_stream_socket<boost::asio::ip::tcp> >; Args = {const std::vector<boost::asio::const_buffer, std::allocator<boost::asio::const_buffer> >&, boost::asio::detail::transfer_all_t}; typename std::enable_if<boost::asio::detail::async_result_has_initiate_memfn<CompletionToken, Signature>::value, decltype (boost::asio::async_result<typename std::decay<_Tp>::type, Signature>::initiate(declval<Initiation&&>(), declval<CompletionToken&&>(), (declval<Args&>)()...))>::type = void]’
/usr/local/include/boost/asio/impl/write.hpp:533:51:   required from ‘auto boost::asio::async_write(AsyncWriteStream&, const ConstBufferSequence&, WriteHandler&&, typename std::enable_if<boost::asio::is_const_buffer_sequence<ConstBufferSequence>::value>::type*) [with AsyncWriteStream = boost::asio::basic_stream_socket<boost::asio::ip::tcp>; ConstBufferSequence = std::vector<boost::asio::const_buffer>; WriteHandler = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; typename std::enable_if<boost::asio::is_const_buffer_sequence<ConstBufferSequence>::value>::type = void]’
cpp/Connection.cpp:79:4:   required from here
/usr/include/c++/9/functional:509:2: note: candidate: ‘template<class ... _Args, class _Result> _Result std::_Bind<_Functor(_Bound_args ...)>::operator()(_Args&& ...) volatile [with _Args = {_Args ...}; _Result = _Result; _Functor = void (Connection::*)(const boost::system::error_code&); _Bound_args = {std::shared_ptr<Connection>, boost::arg<1> (*)()}]’
  509 |  operator()(_Args&&... __args) volatile
      |  ^~~~~~~~
/usr/include/c++/9/functional:509:2: note:   template argument deduction/substitution failed:
/usr/include/c++/9/functional: In substitution of ‘template<class _Functor, class ... _Bound_args> template<class _Fn, class _CallArgs, class ... _BArgs> using _Res_type_impl = typename std::result_of<_Fn&(std::_Bind<_Functor(_Bound_args ...)>::_Mu_type<_BArgs, _CallArgs>&& ...)>::type [with _Fn = std::add_volatile<void (Connection::*)(const boost::system::error_code&)>::type; _CallArgs = std::tuple<const boost::system::error_code&, const long unsigned int&>; _BArgs = {std::add_volatile<std::shared_ptr<Connection> >::type, std::add_volatile<boost::arg<1> (*)()>::type}; _Functor = void (Connection::*)(const boost::system::error_code&); _Bound_args = {std::shared_ptr<Connection>, boost::arg<1> (*)()}]’:
/usr/include/c++/9/functional:454:8:   required by substitution of ‘template<class _Functor, class ... _Bound_args> template<class _CallArgs, template<class _CallArgs, template<class> class __cv_quals> template<class _Functor, class ... _Bound_args> template<class> class __cv_quals> using _Res_type_cv = std::_Bind<_Functor(_Bound_args ...)>::_Res_type_impl<typename __cv_quals<typename std::enable_if<(bool)((std::tuple_size<_Tuple>::value + 1)), _Functor>::type>::type, _CallArgs, typename __cv_quals<_Bound_args>::type ...> [with _CallArgs = std::tuple<const boost::system::error_code&, const long unsigned int&>; __cv_quals = std::add_volatile; _Functor = void (Connection::*)(const boost::system::error_code&); _Bound_args = {std::shared_ptr<Connection>, boost::arg<1> (*)()}]’
/usr/include/c++/9/functional:506:9:   required from ‘void boost::asio::detail::initiate_async_write_buffer_sequence<AsyncWriteStream>::operator()(WriteHandler&&, const ConstBufferSequence&, CompletionCondition&&) const [with WriteHandler = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; ConstBufferSequence = std::vector<boost::asio::const_buffer>; CompletionCondition = boost::asio::detail::transfer_all_t; AsyncWriteStream = boost::asio::basic_stream_socket<boost::asio::ip::tcp>]’
/usr/local/include/boost/asio/async_result.hpp:152:42:   required from ‘static boost::asio::async_result<CompletionToken, Signature>::return_type boost::asio::async_result<CompletionToken, Signature>::initiate(Initiation&&, RawCompletionToken&&, Args&& ...) [with Initiation = boost::asio::detail::initiate_async_write_buffer_sequence<boost::asio::basic_stream_socket<boost::asio::ip::tcp> >; RawCompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; Args = {const std::vector<boost::asio::const_buffer, std::allocator<boost::asio::const_buffer> >&, boost::asio::detail::transfer_all_t}; CompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; Signature = void(boost::system::error_code, long unsigned int); boost::asio::async_result<CompletionToken, Signature>::return_type = void]’
/usr/local/include/boost/asio/async_result.hpp:365:25:   required from ‘typename std::enable_if<boost::asio::detail::async_result_has_initiate_memfn<CompletionToken, Signature>::value, decltype (boost::asio::async_result<typename std::decay<_Tp>::type, Signature>::initiate(declval<Initiation&&>(), declval<CompletionToken&&>(), (declval<Args&>)()...))>::type boost::asio::async_initiate(Initiation&&, CompletionToken&, Args&& ...) [with CompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; Signature = void(boost::system::error_code, long unsigned int); Initiation = boost::asio::detail::initiate_async_write_buffer_sequence<boost::asio::basic_stream_socket<boost::asio::ip::tcp> >; Args = {const std::vector<boost::asio::const_buffer, std::allocator<boost::asio::const_buffer> >&, boost::asio::detail::transfer_all_t}; typename std::enable_if<boost::asio::detail::async_result_has_initiate_memfn<CompletionToken, Signature>::value, decltype (boost::asio::async_result<typename std::decay<_Tp>::type, Signature>::initiate(declval<Initiation&&>(), declval<CompletionToken&&>(), (declval<Args&>)()...))>::type = void]’
/usr/local/include/boost/asio/impl/write.hpp:533:51:   required from ‘auto boost::asio::async_write(AsyncWriteStream&, const ConstBufferSequence&, WriteHandler&&, typename std::enable_if<boost::asio::is_const_buffer_sequence<ConstBufferSequence>::value>::type*) [with AsyncWriteStream = boost::asio::basic_stream_socket<boost::asio::ip::tcp>; ConstBufferSequence = std::vector<boost::asio::const_buffer>; WriteHandler = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; typename std::enable_if<boost::asio::is_const_buffer_sequence<ConstBufferSequence>::value>::type = void]’
cpp/Connection.cpp:79:4:   required from here
/usr/include/c++/9/functional:443:8: error: no type named ‘type’ in ‘class std::result_of<void (Connection::* volatile&(volatile std::shared_ptr<Connection>&, boost::arg<1> (* volatile&)()))(const boost::system::error_code&)>’
  443 |  using _Res_type_impl
      |        ^~~~~~~~~~~~~~
/usr/local/include/boost/asio/basic_datagram_socket.hpp: In instantiation of ‘void boost::asio::detail::initiate_async_write_buffer_sequence<AsyncWriteStream>::operator()(WriteHandler&&, const ConstBufferSequence&, CompletionCondition&&) const [with WriteHandler = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; ConstBufferSequence = std::vector<boost::asio::const_buffer>; CompletionCondition = boost::asio::detail::transfer_all_t; AsyncWriteStream = boost::asio::basic_stream_socket<boost::asio::ip::tcp>]’:
/usr/local/include/boost/asio/async_result.hpp:152:42:   required from ‘static boost::asio::async_result<CompletionToken, Signature>::return_type boost::asio::async_result<CompletionToken, Signature>::initiate(Initiation&&, RawCompletionToken&&, Args&& ...) [with Initiation = boost::asio::detail::initiate_async_write_buffer_sequence<boost::asio::basic_stream_socket<boost::asio::ip::tcp> >; RawCompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; Args = {const std::vector<boost::asio::const_buffer, std::allocator<boost::asio::const_buffer> >&, boost::asio::detail::transfer_all_t}; CompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; Signature = void(boost::system::error_code, long unsigned int); boost::asio::async_result<CompletionToken, Signature>::return_type = void]’
/usr/local/include/boost/asio/async_result.hpp:365:25:   required from ‘typename std::enable_if<boost::asio::detail::async_result_has_initiate_memfn<CompletionToken, Signature>::value, decltype (boost::asio::async_result<typename std::decay<_Tp>::type, Signature>::initiate(declval<Initiation&&>(), declval<CompletionToken&&>(), (declval<Args&>)()...))>::type boost::asio::async_initiate(Initiation&&, CompletionToken&, Args&& ...) [with CompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; Signature = void(boost::system::error_code, long unsigned int); Initiation = boost::asio::detail::initiate_async_write_buffer_sequence<boost::asio::basic_stream_socket<boost::asio::ip::tcp> >; Args = {const std::vector<boost::asio::const_buffer, std::allocator<boost::asio::const_buffer> >&, boost::asio::detail::transfer_all_t}; typename std::enable_if<boost::asio::detail::async_result_has_initiate_memfn<CompletionToken, Signature>::value, decltype (boost::asio::async_result<typename std::decay<_Tp>::type, Signature>::initiate(declval<Initiation&&>(), declval<CompletionToken&&>(), (declval<Args&>)()...))>::type = void]’
/usr/local/include/boost/asio/impl/write.hpp:533:51:   required from ‘auto boost::asio::async_write(AsyncWriteStream&, const ConstBufferSequence&, WriteHandler&&, typename std::enable_if<boost::asio::is_const_buffer_sequence<ConstBufferSequence>::value>::type*) [with AsyncWriteStream = boost::asio::basic_stream_socket<boost::asio::ip::tcp>; ConstBufferSequence = std::vector<boost::asio::const_buffer>; WriteHandler = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; typename std::enable_if<boost::asio::is_const_buffer_sequence<ConstBufferSequence>::value>::type = void]’
cpp/Connection.cpp:79:4:   required from here
/usr/include/c++/9/functional:521:2: note: candidate: ‘template<class ... _Args, class _Result> _Result std::_Bind<_Functor(_Bound_args ...)>::operator()(_Args&& ...) const volatile [with _Args = {_Args ...}; _Result = _Result; _Functor = void (Connection::*)(const boost::system::error_code&); _Bound_args = {std::shared_ptr<Connection>, boost::arg<1> (*)()}]’
  521 |  operator()(_Args&&... __args) const volatile
      |  ^~~~~~~~
/usr/include/c++/9/functional:521:2: note:   template argument deduction/substitution failed:
/usr/include/c++/9/functional: In substitution of ‘template<class _Functor, class ... _Bound_args> template<class _Fn, class _CallArgs, class ... _BArgs> using _Res_type_impl = typename std::result_of<_Fn&(std::_Bind<_Functor(_Bound_args ...)>::_Mu_type<_BArgs, _CallArgs>&& ...)>::type [with _Fn = std::add_cv<void (Connection::*)(const boost::system::error_code&)>::type; _CallArgs = std::tuple<const boost::system::error_code&, const long unsigned int&>; _BArgs = {std::add_cv<std::shared_ptr<Connection> >::type, std::add_cv<boost::arg<1> (*)()>::type}; _Functor = void (Connection::*)(const boost::system::error_code&); _Bound_args = {std::shared_ptr<Connection>, boost::arg<1> (*)()}]’:
/usr/include/c++/9/functional:454:8:   required by substitution of ‘template<class _Functor, class ... _Bound_args> template<class _CallArgs, template<class _CallArgs, template<class> class __cv_quals> template<class _Functor, class ... _Bound_args> template<class> class __cv_quals> using _Res_type_cv = std::_Bind<_Functor(_Bound_args ...)>::_Res_type_impl<typename __cv_quals<typename std::enable_if<(bool)((std::tuple_size<_Tuple>::value + 1)), _Functor>::type>::type, _CallArgs, typename __cv_quals<_Bound_args>::type ...> [with _CallArgs = std::tuple<const boost::system::error_code&, const long unsigned int&>; __cv_quals = std::add_cv; _Functor = void (Connection::*)(const boost::system::error_code&); _Bound_args = {std::shared_ptr<Connection>, boost::arg<1> (*)()}]’
/usr/include/c++/9/functional:518:9:   required from ‘void boost::asio::detail::initiate_async_write_buffer_sequence<AsyncWriteStream>::operator()(WriteHandler&&, const ConstBufferSequence&, CompletionCondition&&) const [with WriteHandler = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; ConstBufferSequence = std::vector<boost::asio::const_buffer>; CompletionCondition = boost::asio::detail::transfer_all_t; AsyncWriteStream = boost::asio::basic_stream_socket<boost::asio::ip::tcp>]’
/usr/local/include/boost/asio/async_result.hpp:152:42:   required from ‘static boost::asio::async_result<CompletionToken, Signature>::return_type boost::asio::async_result<CompletionToken, Signature>::initiate(Initiation&&, RawCompletionToken&&, Args&& ...) [with Initiation = boost::asio::detail::initiate_async_write_buffer_sequence<boost::asio::basic_stream_socket<boost::asio::ip::tcp> >; RawCompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; Args = {const std::vector<boost::asio::const_buffer, std::allocator<boost::asio::const_buffer> >&, boost::asio::detail::transfer_all_t}; CompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; Signature = void(boost::system::error_code, long unsigned int); boost::asio::async_result<CompletionToken, Signature>::return_type = void]’
/usr/local/include/boost/asio/async_result.hpp:365:25:   required from ‘typename std::enable_if<boost::asio::detail::async_result_has_initiate_memfn<CompletionToken, Signature>::value, decltype (boost::asio::async_result<typename std::decay<_Tp>::type, Signature>::initiate(declval<Initiation&&>(), declval<CompletionToken&&>(), (declval<Args&>)()...))>::type boost::asio::async_initiate(Initiation&&, CompletionToken&, Args&& ...) [with CompletionToken = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; Signature = void(boost::system::error_code, long unsigned int); Initiation = boost::asio::detail::initiate_async_write_buffer_sequence<boost::asio::basic_stream_socket<boost::asio::ip::tcp> >; Args = {const std::vector<boost::asio::const_buffer, std::allocator<boost::asio::const_buffer> >&, boost::asio::detail::transfer_all_t}; typename std::enable_if<boost::asio::detail::async_result_has_initiate_memfn<CompletionToken, Signature>::value, decltype (boost::asio::async_result<typename std::decay<_Tp>::type, Signature>::initiate(declval<Initiation&&>(), declval<CompletionToken&&>(), (declval<Args&>)()...))>::type = void]’
/usr/local/include/boost/asio/impl/write.hpp:533:51:   required from ‘auto boost::asio::async_write(AsyncWriteStream&, const ConstBufferSequence&, WriteHandler&&, typename std::enable_if<boost::asio::is_const_buffer_sequence<ConstBufferSequence>::value>::type*) [with AsyncWriteStream = boost::asio::basic_stream_socket<boost::asio::ip::tcp>; ConstBufferSequence = std::vector<boost::asio::const_buffer>; WriteHandler = std::_Bind<void (Connection::*(std::shared_ptr<Connection>, boost::arg<1> (*)()))(const boost::system::error_code&)>; typename std::enable_if<boost::asio::is_const_buffer_sequence<ConstBufferSequence>::value>::type = void]’
cpp/Connection.cpp:79:4:   required from here
/usr/include/c++/9/functional:443:8: error: no type named ‘type’ in ‘class std::result_of<void (Connection::* const volatile&(const volatile std::shared_ptr<Connection>&, boost::arg<1> (* const volatile&)()))(const boost::system::error_code&)>’
  443 |  using _Res_type_impl
      |        ^~~~~~~~~~~~~~
